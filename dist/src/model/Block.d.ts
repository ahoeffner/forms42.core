import { Form } from "./Form.js";
import { Filter } from "./interfaces/Filter.js";
import { Record } from "./Record.js";
import { Relation } from "./relations/Relation.js";
import { Block as ViewBlock } from '../view/Block.js';
import { FilterStructure } from "./FilterStructure.js";
import { DataSource } from "./interfaces/DataSource.js";
import { MemoryTable } from "./datasources/MemoryTable.js";
import { DataSourceWrapper } from "./DataSourceWrapper.js";
import { EventType } from "../control/events/EventType.js";
import { Block as InterfaceBlock } from '../public/Block.js';
export declare class Block {
    private form$;
    private name$;
    private record$;
    private view$;
    private queried$;
    private ctrlblk$;
    private source$;
    private pubfrm$;
    private pubblk$;
    private qbe;
    private filter;
    constructor(form: Form, name: string);
    get name(): string;
    get form(): Form;
    get pubblk(): InterfaceBlock;
    get empty(): boolean;
    get view(): ViewBlock;
    get ctrlblk(): boolean;
    get queried(): boolean;
    set queried(flag: boolean);
    get qberec(): Record;
    get querymode(): boolean;
    set querymode(flag: boolean);
    set ctrlblk(flag: boolean);
    get qbeallowed(): boolean;
    get queryallowed(): boolean;
    get insertallowed(): boolean;
    get updateallowed(): boolean;
    get deleteallowed(): boolean;
    set dirty(flag: boolean);
    get dirty(): boolean;
    clear(flush: boolean): Promise<boolean>;
    hasEventTransaction(): boolean;
    checkEventTransaction(event: EventType): Promise<boolean>;
    setEventTransaction(event: EventType, record: Record): Promise<boolean>;
    endEventTransaction(event: EventType, success: boolean): void;
    get datasource(): DataSource;
    set datasource(source: DataSource);
    reset(source: boolean): void;
    addColumns(fields?: string[]): void;
    createMemorySource(recs?: number, columns?: string[]): MemoryTable;
    get wrapper(): DataSourceWrapper;
    preInsert(record: Record): Promise<boolean>;
    postInsert(record: Record): Promise<boolean>;
    preUpdate(record: Record): Promise<boolean>;
    postUpdate(record: Record): Promise<boolean>;
    preDelete(record: Record): Promise<boolean>;
    postDelete(record: Record): Promise<boolean>;
    preQuery(): Promise<boolean>;
    onFetch(record: Record): Promise<boolean>;
    postQuery(): Promise<boolean>;
    validateField(record: Record, field: string): Promise<boolean>;
    validateRecord(): Promise<boolean>;
    rewind(): void;
    move(delta: number): number;
    get record(): number;
    set record(record: number);
    get interface(): InterfaceBlock;
    getValue(field: string): any;
    setValue(field: string, value: any): boolean;
    locked(record?: Record): boolean;
    lock(record?: Record): Promise<boolean>;
    refresh(offset: number, reset: boolean): Promise<void>;
    insert(before?: boolean): Promise<boolean>;
    delete(): Promise<boolean>;
    getDirtyCount(): number;
    getPendingCount(): number;
    undo(requery: boolean): Promise<boolean>;
    flush(): Promise<boolean>;
    setFilter(field: string, filter?: Filter | FilterStructure): void;
    cancel(): void;
    enterQuery(): Promise<boolean>;
    executeQuery(qryid: object): Promise<boolean>;
    showLastQuery(): void;
    scroll(records: number, offset: number): number;
    getQueryMaster(): Block;
    get QueryFilter(): FilterStructure;
    get MasterFilter(): FilterStructure;
    get DetailFilter(): FilterStructure;
    getDetailBlockFilter(block: Block, create?: boolean): FilterStructure;
    getMasterBlockFilter(block: Block, create?: boolean): FilterStructure;
    getMasterBlock(link: Relation): Block;
    getMasterBlocks(): Block[];
    getMasterLinks(): Relation[];
    getDetailBlock(link: Relation): Block;
    getDetailBlocks(all: boolean): Block[];
    findMasterRelation(master: Block): Relation;
    getDetailLinks(): Relation[];
    getAllDetailBlocks(all: boolean): Block[];
    setMasterDependencies(): boolean;
    setDetailDependencies(): Promise<boolean>;
    getQueryID(): object;
    startNewQueryChain(): object;
    queryDetails(newqry: boolean): Promise<boolean>;
    prefetch(records: number, offset: number): Promise<number>;
    getRecord(offset?: number): Record;
    copy(header?: boolean, all?: boolean): Promise<any[][]>;
    finalize(): void;
    private asSubQuery;
    fire(type: EventType, field?: string): Promise<boolean>;
}
